#include <algorithm>
#include <iomanip>

#include "mamec/metrics.hpp"

namespace mamefont::mamec {

static std::string compPerf(std::string label, int genFrags, int numInsts,
                            float ratio) {
  std::ostringstream oss;
  char ratioSign = ratio < 0 ? '-' : ratio == 0 ? ' ' : '+';
  ratio = std::abs(ratio);
  oss << s2s(label, 6) << ": " << i2s(genFrags) << " --> " << i2s(numInsts)
      << " " << "(" << ratioSign << f2s(ratio, 5, 2) << "%)";
  return oss.str();
}

void dumpMetrics(const std::vector<uint8_t> &blob, std::ostream &os,
                 const std::string &indent) {
  mf::Status ret;
  const mf::Font font(blob.data());

  int firstCode = font.firstCode();
  int lastCode = font.lastCode();
  int numGlyphs = lastCode - firstCode + 1;

  int glyphTableOffset = mf::FontHeader::SIZE;
  int fragTableOffset = font.fragmentTableOffset();
  int byteCodeOffset = font.byteCodeOffset();

  int gtSize = fragTableOffset - glyphTableOffset;
  int ftSize = byteCodeOffset - fragTableOffset;
  int bcSize = blob.size() - byteCodeOffset;

  float gtPerGlyph = (float)gtSize / (numGlyphs);
  float ftUsage = (float)ftSize * 100 / mf::MAX_FRAGMENT_TABLE_SIZE;
  float bcPerGlyph = (float)bcSize / (numGlyphs);
  float totalPerGlyph = (float)blob.size() / (numGlyphs);

  std::vector<std::pair<std::string, mf::Operator>> operators;
  for (int i = 0; i < static_cast<int>(mf::Operator::COUNT); i++) {
    auto op = static_cast<mf::Operator>(i);
    if (op == mf::Operator::NONE || op == mf::Operator::ABO) continue;
    operators.emplace_back(mf::mnemonicOf(op), op);
  }
  std::sort(operators.begin(), operators.end(),
            [](const auto &a, const auto &b) { return a.first < b.first; });

  std::map<mf::Operator, int> codeSizePerOp;
  std::map<mf::Operator, int> genFragsPerOp;
  for (const auto &opPair : operators) {
    auto op = opPair.second;
    codeSizePerOp[op] = 0;
    genFragsPerOp[op] = 0;
  }

  uint8_t stride;
  std::vector<uint8_t> bufferVec(font.calcGlyphBufferSize(&stride) * 2);
  mf::GlyphBuffer glyphBuff(bufferVec.data(), stride);

  int numTotalPixels = 0;
  int totalGenFrags = 0;
  int totalCodeSize = 0;

  for (int code = firstCode; code <= lastCode; code++) {
    mf::Glyph glyph;
    try {
      ret = font.getGlyph(code, &glyph);
    } catch (const mf::MameFontException &e) {
      ret = e.status;
    }
    if (ret != mf::Status::SUCCESS) continue;

    mf::StateMachine stm(font);
    ret = stm.run(glyph, glyphBuff);
    if (ret != mf::Status::SUCCESS) continue;

    numTotalPixels += glyph.glyphWidth * font.glyphHeight();
    for (const auto &opPair : operators) {
      auto op = opPair.second;
      int codeSize = stm.numInstsPerOperator[static_cast<int>(op)] * mf::instSizeOf(op);
      int genFrags = stm.generatedFragsPerOperator[static_cast<int>(op)];
      codeSizePerOp[op] += codeSize;
      genFragsPerOp[op] += genFrags;
      totalCodeSize += codeSize;
      totalGenFrags += genFrags;
    }
  }
  float totalCompRatio =
      100.0f * (totalCodeSize - totalGenFrags) / totalGenFrags;
  float memEff = (float)numTotalPixels / blob.size();

  auto fragShape = font.verticalFragment() ? "Vertical" : "Horizontal";
  auto bitOrder = font.msb1st() ? "MSB First" : "LSB First";

  // Generated by MameFont
  // clang-format off
  os << indent << "Format Version: " << (int)font.formatVersion() << "\n";
  os << indent << "First Code      : " << c2s(font.firstCode()) << "\n";
  os << indent << "Last Code       : " << c2s(font.lastCode()) << "\n";
  os << indent << "Font Height     : " << i2s(font.glyphHeight(), 1) << " px\n";
  os << indent << "Max Glyph Width : " << i2s(font.maxGlyphWidth(), 1) << " px\n";
  os << indent << "Total Pixels    : " << i2s(numTotalPixels, 1) << " px\n";
  os << indent << "Fragment Shape  : " << fragShape << "\n";
  os << indent << "Bit Order       : " << bitOrder << "\n";
  os << indent << "Large Font      : " << yn(font.largeFont()) << "\n";
  os << indent << "Proportional    : " << yn(font.proportional()) << "\n";
  os << indent << "Ext. Header     : " << yn(font.hasExtendedHeader()) << "\n";
  os << indent << "Estimated Footprint:\n";
  os << indent << "  Header        : " << i2s(mf::FontHeader::SIZE, 4) << " Bytes\n";
  os << indent << "  Glyph Table   : " << i2s(gtSize, 4) << " Bytes (" << f2s(gtPerGlyph, 6, 2) << " Bytes/glyph)\n";
  os << indent << "  Frag. Table   : " << i2s(ftSize, 4) << " Bytes (" << f2s(ftUsage, 6, 2) << "% used)\n";
  os << indent << "  Bytecodes     : " << i2s(bcSize, 4) << " Bytes (" << f2s(bcPerGlyph, 6, 2) << " Bytes/glyph)\n";
  os << indent << "  Total         : " << i2s(blob.size(), 4) << " Bytes (" << f2s(totalPerGlyph, 6, 2) << " Bytes/glyph)\n";
  os << indent << "Compression Performance:\n";
  int totalDiff = totalGenFrags - totalCodeSize;
  for (const auto &opPair : operators) {
    auto op = opPair.second;
    int numInsts = codeSizePerOp[op];
    int genFrags = genFragsPerOp[op];
    if (numInsts == 0 && genFrags == 0) continue;
    float ratio = totalDiff == 0 ? 0.0f : (totalCompRatio * (genFrags - numInsts) / totalDiff);
    os << indent << "  " << compPerf(mf::mnemonicOf(op), genFrags, numInsts, ratio) << "\n";
  }
  os << indent << "  " << compPerf("Total", totalGenFrags, totalCodeSize, totalCompRatio) << "\n";
  os << indent << "Memory Efficiency: " << f2s(memEff, 6, 3) << " px/Byte\n";
  // clang-format on
}

}  // namespace mamefont::mamec
